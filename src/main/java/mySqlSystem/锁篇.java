package mySqlSystem;

public class 锁篇 {
}
/**
 *      锁是什么？
 *          锁是数据库用来解决并发操作的手段 保证数据的正确性
 *      锁都有哪些种类？
 *          1.全局锁
 *          2.表级锁
 *          3.行锁
 *      全局锁：
 *          让整个库处于只读状态，适用场景用于主从备份
 *          使用mysql自带工具 mysql dump 设置 single-transaction
 *          此时mysql会启动一个事务 拿到一致性视图 因为隔离级别是的可重复读
 *          所以保证了逻辑的一致性
 *      表级锁：
 *          表级锁分为表锁和元数据锁
 *          表锁显视用法： lock table [tab_name] read/writer
 *          元数据锁（非显视）：
 *      ------------以上的锁由mysql自身实现
 *      行锁：
 *          由存储引擎自己实现 有些存储引擎没有行锁
 *          行锁就是字面意思 锁住一行数据
 *          有个很重要的地方需要注意
 *          当开启一个事务的时候 这个事务拿不到行锁
 *          而是只有执行到需要行锁的地方才会拿到行锁
 *          只有等事务结束才会释放行锁 ----两阶段锁协议
 *          这就会发生一个问题：死锁
 *              事务1       事务2
 *              begin
 *              获取行锁2    begin
 *                         获取行锁1
 *              等待行锁1   等待行锁2
 *           结果就是谁都不释放锁 相互等待 发生死锁
 *       死锁的解决策略：
 *          1.等待超时 设置参数 让超时时间缩短 默认50s
 *              缺点：时间长 程序受不了 时间短 容易误伤  还没发判断到底设置多少合适
 *          2.主动进行死锁检测（默认开启）
 *              缺点：死锁检测是O(n)的复杂度，当并发太多的时候，大量消耗cpu资源都用在
 *                   检测上了, 事务根本执行不了几条
 *          第一种的缺陷实在太大 所以一般采用第二种解决方案
 *          第二种的缺陷就在于消耗cpu资源 如果我们能控制并发检测 就好了
 *       如何控制并发程度：
 *          1.修改mysql源码
 *          2.采用中间件
 *          3.设计上优化 对一条数据行进行拆分 减少行冲突
 *          4.我自己想的是 分库分表 然后 再弄一个主数库只对子数据库读数据做统计累加和
 *
 *
 *
 *
 *
 *
 * */